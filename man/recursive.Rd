% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/modeltime-recursive.R
\name{recursive}
\alias{recursive}
\title{Create a Recursive Time Series Model from a Parsnip or Workflow Regression Model}
\usage{
recursive(object, transform, train_tail, id = NULL, ...)
}
\arguments{
\item{object}{An object of \code{model_fit} or a fitted \code{workflow} class}

\item{transform}{A transformation performed on new_data after
each step of recursive algorithm. It can be an object of types:
\itemize{
\item \strong{Method 1, \code{recipe}:} A recipe generates lagged or sliding features (see examples)
\item \strong{Method 2, \code{function}:} Must have one argument \code{data} (see examples)
}}

\item{train_tail}{A tibble with tail of training data set.
In most cases it'll be required to create some variables
based on dependent variable.}

\item{id}{(Optional) An identifier that can be provided to perform a panel forecast.
A single quoted column name (e.g. \code{id = "id"}).}

\item{...}{Not currently used.}
}
\value{
An object with added \code{recursive} class
}
\description{
Create a Recursive Time Series Model from a Parsnip or Workflow Regression Model
}
\details{
Recursive model can be used if some of the features used for training
is based of dependent variable we already are trying to forecast.
Typically, among these features we can find lags (e.g. created with \code{step_lag()})
or variables crated with sliding window.

When producing forecast, the following steps are performed:
\enumerate{
\item Computing forecast for first row of new data.
The first row cannot contain NA in any required column.
\item Filling i-th place of the dependent variable column with
already computed forecast.
\item Computing missing features for next step, based on
already calculated prediction. These features are computed
with on a tibble object made from binded \code{train_tail} (i.e. tail of
training data set) and \code{new_data} (which is an argument of predict function).
\item Jumping into point 2., and repeating rest of steps till the for-loop is ended.
}
}
\examples{
# Libraries & Setup ----
library(modeltime)
library(tidymodels)
library(tidyverse)
library(lubridate)
library(timetk)
library(slider)

# ---- SINGLE TIME SERIES (NON-PANEL) -----

m750

FORECAST_HORIZON <- 24

m750_extended <- m750 \%>\%
    group_by(id) \%>\%
    future_frame(
        .length_out = FORECAST_HORIZON,
        .bind_data  = TRUE
    ) \%>\%
    ungroup()

# TRANSFORM FUNCTION ----
# - Function runs recursively that updates the forecasted dataset
lag_roll_transformer <- function(data){
    data \%>\%
        # Lags
        tk_augment_lags(value, .lags = 1:12) \%>\%
        # Rolling Features
        mutate(rolling_mean_12 = lag(slide_dbl(
            value, .f = mean, .before = 12, .complete = FALSE
        ), 1))
}

# Data Preparation
m750_rolling <- m750_extended \%>\%
    lag_roll_transformer() \%>\%
    select(-id)

train_data <- m750_rolling \%>\%
    drop_na()

future_data <- m750_rolling \%>\%
    filter(is.na(value))

# Modeling

# Straight-Line Forecast
model_fit_lm <- linear_reg() \%>\%
    set_engine("lm") \%>\%
    # Use only date feature as regressor
    fit(value ~ date, data = train_data)

# Autoregressive Forecast
model_fit_lm_recursive <- linear_reg() \%>\%
    set_engine("lm") \%>\%
    # Use date plus all lagged features
    fit(value ~ ., data = train_data) \%>\%
    # Add recursive() w/ transformer and train_tail
    recursive(
        transform  = lag_roll_transformer,
        train_tail = tail(train_data, FORECAST_HORIZON)
    )

model_fit_lm_recursive

# Forecasting
modeltime_table(
    model_fit_lm,
    model_fit_lm_recursive
) \%>\%
    update_model_description(2, "LM - Lag Roll") \%>\%
    modeltime_forecast(
        new_data    = future_data,
        actual_data = m750
    ) \%>\%
    plot_modeltime_forecast(
        .interactive        = FALSE,
        .conf_interval_show = FALSE
    )

# MULTIPLE TIME SERIES (PANEL DATA) -----

m4_monthly

FORECAST_HORIZON <- 24

m4_extended <- m4_monthly \%>\%
    group_by(id) \%>\%
    future_frame(
        .length_out = FORECAST_HORIZON,
        .bind_data  = TRUE
    ) \%>\%
    ungroup()

# TRANSFORM FUNCTION ----
# - NOTE - We create lags by group
lag_transformer_grouped <- function(data){
    data \%>\%
        group_by(id) \%>\%
        tk_augment_lags(value, .lags = 1:FORECAST_HORIZON) \%>\%
        ungroup()
}

m4_lags <- m4_extended \%>\%
    lag_transformer_grouped()

train_data <- m4_lags \%>\%
    drop_na()

future_data <- m4_lags \%>\%
    filter(is.na(value))

# Modeling Autoregressive Panel Data
model_fit_lm_recursive <- linear_reg() \%>\%
    set_engine("lm") \%>\%
    fit(value ~ ., data = train_data) \%>\%
    recursive(
        id         = "id", # We add an id = "id" to specify the groups
        transform  = lag_transformer_grouped,
        # We use panel_tail() to grab tail by groups
        train_tail = panel_tail(train_data, id, FORECAST_HORIZON)
    )

modeltime_table(
    model_fit_lm_recursive
) \%>\%
    modeltime_forecast(
        new_data    = future_data,
        actual_data = m4_monthly,
        keep_data   = TRUE
    ) \%>\%
    group_by(id) \%>\%
    plot_modeltime_forecast(
        .interactive = FALSE,
        .conf_interval_show = FALSE
    )


}
